#include "ipaus.hpp"
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::metadata::init(){
  ip_idcounter = 0;
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::customer::init(){
   type = 0; // Small/Medium enterprise
   
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::intelprop::init(){
   
   intelprop_id = 0;
   
   apply_year = 0;
   
   merge_target = 0;
   merged = false;
   
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::mergerec::init(){
   // nothing to init
   file_time = now();
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::employee::init(){
   employed = true;
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
bool ipaus::employee_active(account_name leacc){
   EMPLOYEE employees(_self);
      // accessing tables in EOS have to be done this way - with a multi index accessor
      // the above is a convenient typedef
   
   return employees.has(leacc);
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void ipaus::createcust(account_name empacc, account_name accname, const string& fullname, const string& ipa_id){
   
   // an authorized account 
   // an employee has to be the one that creates the customer
   
   require_auth(empacc);
      // depending on business rules. Here, we're assuming that an employee needs to be the one that creates the customer account
      // if this function fails, the transaction will fail. no need for error handling code
   
   x_assert(employee_active(empacc), "Employee is not active : " + stringify(empacc));
      // if this assertion fails, transaction won't push. it'll come up as an error.
      // assertions generally work like that. x_assert is a helper function that calls
      // eosio_assert, but this can take in string expressions
   
   CUSTOMERS custs(_self);
      // an accessor for the table
   
   x_assert(!custs.has(accname), "Customer already exists : " + stringify(accname));
   
   customer newrecord;
   newrecord.account = accname;
   newrecord.name = fullname;
   newrecord.ipa_customer_id = ipa_id;
   newrecord.type = 0; // for now, default to small/medium enterprise. We'd add a modifier function later
   
   custs.save(accname, newrecord);
   // first argument to the above call is actually the payer for RAM.
   // in EOS network, RAM (database usage) is something to be paid for using tokens
   // but in our ChainIP network, it's not really a problem, so it doesn't really matter.
   // but still gotta pass in a valid account
   
   
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// Note: these are just for illustration
// I have no idea what the actual organization rules of IPAustralia is, and I doubt
// I could have gotten it right in a single weekend
////////////////////////////////////////////////////////////////////////////
void ipaus::mergeip(account_name approver, int64_t ip1, int64_t ip2){
   
   INTELPROP props(_self);
   
   require_auth(approver);
   x_assert(employee_active(approver), "Employee is not active : " + stringify(approver));
   
   x_assert(props.has(ip1), "Bad IP ID (1st arg) : " + stringify(ip1));
   x_assert(props.has(ip2), "Bad IP ID (2nd arg) : " + stringify(ip2));
   
   intelprop firstip = props.mustfetch(ip1);
   intelprop secondip = props.mustfetch(ip2);
   
   x_assert(!firstip.merged, "IP Already merged : " + firstip.ip_num);
   x_assert(!secondip.merged, "IP Already merged : " + secondip.ip_num);
   
   // make sure applicants are the same
   
   CUSTOMER custs(_self);
   x_assert(custs.has(firstip.owner), "First IP has no owner?");
   x_assert(custs.has(secondip.owner), "First IP has no owner?");
   
   customer firstcust = custs.mustfetch(firstip.owner);
   customer secondcust = custs.mustfetch(secondip.owner);
   
   x_assert(firstcust.abn == secondcust.abn, "ABN does not match!");
   x_assert(firstcust.acn == secondcust.acn, "ACN does not match!");
   
   // All the tests passed! (there might be more tests, but I don't know the actual organization rules yet)
   
   secondip.merged = true;
   secondip.merge_target = ip1;
   
   custs.save(approver, secondip);
   
   
}
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
EOSIO_ABI(ipaus, (createcust)(fileip)(approveip)(rejectip)(mergeip))
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
